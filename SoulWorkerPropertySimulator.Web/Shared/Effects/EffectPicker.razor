@using SoulWorkerPropertySimulator.Extensions
@implements IDisposable

<div>
    @if (Options.Any())
    {
        <div>
            <select @bind="SelectedKey">
                @if (Options.Count > 1) { <option></option> }
                @foreach (var item in Options)
                {
                    <option value="@item.GetHashCode()" disabled="@DisableContext?.Contains(item)">@item.Context.Property.GetDescription()</option>
                }
            </select>
        </div>
        <div>
            @if (SelectedContext != null)
            {
                <div>Min: @SelectedContext.DisplayMinValue</div>
                <div>
                    <input type="number" min="@SelectedContext.DisplayMinValue" max="@SelectedContext.DisplayMaxValue" @bind="SelectedValue"/>
                </div>
                <div>Max: @SelectedContext.DisplayMaxValue</div>
            }
        </div>
    }
</div>

@code {

    private EffectsCreator? _parents;

    [CascadingParameter(Name = nameof(Parents))]
    public EffectsCreator? Parents
    {
        get => _parents;
        set
        {
            _parents?.Pickers.Remove(this);
            _parents = value;
            value?.Pickers.Add(this);
        }
    }

    [Parameter]
    public EventCallback NotifyUpdate { get; set; }

    [Parameter]
    public EventCallback<EffectPicker> RefreshOther { get; set; }

    [Parameter]
    public int? Key { get; set; }
    
    [Parameter]
    public IReadOnlyCollection<EffectRandomContext> Options { get; set; }

    [Parameter]
    public IReadOnlyCollection<EffectRandomContext>? DisableContext { get; set; }

    [Parameter]
    public Effect? DefaultEffect { get; set; }

    private int? _selectedKey;

    public EffectRandomContext? SelectedContext
    {
        get => Options.FirstOrDefault(x => x.GetHashCode() == SelectedKey);
        set => SelectedKey = value?.GetHashCode();
    }

    private int? SelectedKey
    {
        get => _selectedKey;
        set
        {
            _selectedKey = value;
            SelectedValue = SelectedContext?.DisplayMaxValue;
            RefreshOther.InvokeAsync(this);
        }
    }

    private decimal? _selectedValue;

    public int? SelectedValue
    {
        get => (int?) (SelectedContext == null ? null : SelectedContext.Context.IsPercent ? _selectedValue * 100 : _selectedValue);
        set
        {
            _selectedValue = SelectedContext == null ? null : SelectedContext.Context.IsPercent ? value / 100m : value;
            NotifyUpdate.InvokeAsync();
        }
    }

    public Effect? Effect => _selectedValue == null ? null : SelectedContext?.CreateEffect(_selectedValue.Value);

    public void Refresh() { StateHasChanged(); }

    private bool _processDefault = false;

    protected override void OnInitialized()
    {
        base.OnInitializedAsync();
        _processDefault = DefaultEffect != null;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (_processDefault && DefaultEffect != null)
        {
            _selectedKey = Options.First(x => x.Context.Equals(DefaultEffect.Context)).GetHashCode();
            _selectedValue = DefaultEffect.Value;
            RefreshOther.InvokeAsync(this);
            _processDefault = false;
        }
        else if (Options.Count == 1 && Options.First() != SelectedContext) { SelectedContext = Options.First(); }
    }

    public void Dispose() => Parents?.Pickers.Remove(this);

}