@using SoulWorkerPropertySimulator.Extensions
@implements IDisposable

<div>
    @if (Options.Any())
    {
        <div>
            <select @bind="SelectedKey">
                <option></option>
                @foreach (var item in Options)
                {
                    <option value="@item.Context.GetHashCode()" disabled="@DisableContext?.Contains(item)">@item.Context.Property.GetDescription()</option>
                }
            </select>
        </div>
        <div>
            @if (SelectedContext != null)
            {
                <div>Min: @SelectedContext.DisplayMinValue</div>
                <div>
                    <input type="number" min="@SelectedContext.DisplayMinValue" max="@SelectedContext.DisplayMaxValue" @bind="SelectedValue"/>
                </div>
                <div>Max: @SelectedContext.DisplayMaxValue</div>
            }
        </div>
    }
</div>

@code {

    [CascadingParameter(Name = nameof(Parents))]
    public EffectsCreator Parents { get; set; } = null!;

    [Parameter]
    public EventCallback NotifyUpdate { get; set; }

    [Parameter]
    public EventCallback<EffectPicker> RefreshOther { get; set; }

    [Parameter]
    public int? Key { get; set; }

    [Parameter]
    public IReadOnlyCollection<EffectRandomContext> Options { get; set; } = null!;

    private IReadOnlyCollection<EffectRandomContext>? _disableContext;

    [Parameter]
    public IReadOnlyCollection<EffectRandomContext>? DisableContext
    {
        get => _disableContext;
        set
        {
            _disableContext = value;
            if (value == null) { return; }
            if (_notInitializePhase && value.Contains(SelectedContext)) { SelectedKey = Options.First(x => !value.Contains(x)).Context.GetHashCode(); }
        }
    }

    private Effect? _defaultEffect;

    [Parameter]
    public Effect? DefaultEffect
    {
        set
        {
            if (value == null || _notInitializePhase) { return; }

            _defaultEffect = value;
            SelectedContext = Options.First(x => x.Context.Equals(value.Context));
            _selectedValue = value.Value;
        }
    }

    private int? _selectedKey;

    public EffectRandomContext? SelectedContext
    {
        get => Options.FirstOrDefault(x => x.Context.GetHashCode() == SelectedKey);
        set => SelectedKey = value?.Context.GetHashCode();
    }

    private int? SelectedKey
    {
        get => _selectedKey;
        set
        {
            if (_selectedKey == value) { return; }
            _selectedKey = value;
            SelectedValue = SelectedContext?.DisplayMaxValue;
            if (_notInitializePhase || _defaultEffect == null) { RefreshOther.InvokeAsync(this); }
        }
    }

    private decimal? _selectedValue;

    public int? SelectedValue
    {
        get => (int?) (SelectedContext == null ? null : SelectedContext.Context.IsPercent ? _selectedValue * 100 : _selectedValue);
        set
        {
            _selectedValue = SelectedContext == null ? null : SelectedContext.Context.IsPercent ? value / 100m : value;
            if (_notInitializePhase) { NotifyUpdate.InvokeAsync(); }
        }
    }

    public Effect? Effect => _selectedValue == null ? null : SelectedContext?.CreateEffect(_selectedValue.Value);

    public void Refresh() { StateHasChanged(); }

    private bool _notInitializePhase;

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (firstRender) { _notInitializePhase = true; }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Parents.Pickers.Add(this);
    }

    public void Dispose() { Parents.Pickers.Remove(this); }

}