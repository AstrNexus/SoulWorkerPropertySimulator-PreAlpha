@using SoulWorkerPropertySimulator.Models
<h3>EffectCreator</h3>

@if (Count > Contexts.Count) { <div>Error</div> }
else
{
    <div>
        <CascadingValue Name="Parents" Value="this" IsFixed="true">
            @if (Count == Contexts.Count)
            {
                @foreach (var item in Contexts)
                {
                    <EffectPicker NotifyUpdate="NotifyUpdate" Contexts="new[] {item}"/>
                }
            }
            else
            {
                @for (var i = 0; i < Count; i++)
                {
                    <EffectPicker Key="i" ReRenderOther="ReRenderOther" NotifyUpdate="NotifyUpdate" Contexts="Contexts" DefaultEffect="DefaultEffectList?.Count > i ? DefaultEffectList[i] : null" DisableContext="this[i]"/>
                }
            }
        </CascadingValue>
    </div>
}

@code {

    [Parameter]
    public Blueprint Blueprint { get; set; } = null!;

    [Parameter]
    public IReadOnlyCollection<Effect>? DefaultEffects { get; set; }

    [Parameter]
    public EventCallback NotifyUpdate { get; set; }

    public ICollection<EffectPicker> Pickers { get; } = new List<EffectPicker>();
    private IReadOnlyList<Effect>? DefaultEffectList => DefaultEffects?.ToList();
    private int Count => Blueprint.RandomEffectCount;
    private IReadOnlyCollection<EffectRandomContext> Contexts => Blueprint.RandomEffects;
    public IReadOnlyCollection<Effect> Effects => Pickers.Select(x => x.Effect).Where(x => x != null)!.ToList();
    private IReadOnlyCollection<EffectRandomContext> this[int key] => Pickers.Where(x => x.Key.HasValue && x.Key != key && x.Effect != null).Select(x => x.SelectedContext)!.ToList();

    // private IReadOnlyCollection<EffectRandomContext> GetDisableContext(int key) => Pickers.Where(x => x.Key.HasValue && x.Key != key && x.Effect != null).Select(x => x.SelectedContext)!.ToList<EffectRandomContext>();

    private void ReRenderOther(EffectPicker self)
    {
        foreach (var i in Pickers.Where(x => x != self)) { i.ReRender(); }
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        base.OnAfterRenderAsync(firstRender);

        if (firstRender) { NotifyUpdate.InvokeAsync(); }

        return Task.CompletedTask;
    }

}